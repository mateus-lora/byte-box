package br.edu.atitus.product_service.controllers;

import java.util.List;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.cache.CacheManager;
import org.springframework.context.annotation.Fallback;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.edu.atitus.product_service.clients.CurrencyClient;
import br.edu.atitus.product_service.clients.CurrencyResponse;
import br.edu.atitus.product_service.entities.ProductEntity;
import br.edu.atitus.product_service.repositories.ProductRepository;

@RestController
@RequestMapping("products")
public class OpenProductController {

	private final ProductRepository repository;
	private final CurrencyClient currencyClient;
	private final CacheManager cacheManager;

	public OpenProductController(ProductRepository repository, CurrencyClient currencyClient,
			CacheManager cacheManager) {
		super();
		this.repository = repository;
		this.currencyClient = currencyClient;
		this.cacheManager = cacheManager;
	}

	@Value("${server.port}")
	private int serverPort;

	@GetMapping("/{idProduct}/{targetCurrency}")
	public ResponseEntity<ProductEntity> getProduct(@PathVariable Long idProduct, @PathVariable String targetCurrency)
			throws Exception {

		targetCurrency = targetCurrency.toUpperCase();
		String nameCache = "Product";
		String keyCache = idProduct + targetCurrency;

		ProductEntity product = cacheManager.getCache(nameCache).get(keyCache, ProductEntity.class);

		if (product == null) {
			product = repository.findById(idProduct).orElseThrow(() -> new Exception("Product not found"));
			
			product.setEnvironment("Product-service running on Port: " + serverPort);

			if (product.getCurrency().equals(targetCurrency)) {
				product.setConvertedPrice(product.getPrice());
			} else {
				CurrencyResponse currency = currencyClient.getCurrency(product.getPrice(), product.getCurrency(),
						targetCurrency);
				if (currency != null) {
					product.setConvertedPrice(currency.getConvertedValue());
					product.setEnvironment(product.getEnvironment() + " - " + currency.getEnviroment());
					
					cacheManager.getCache(nameCache).put(keyCache, product);
				} else {
					product.setConvertedPrice(-1);
					product.setEnvironment(product.getEnvironment() + " - Currency unavalaible");
				}
			}
			
		} else {
			product.setEnvironment("Product-service running on Port: " + serverPort + " - Datasource: cache");
		}
		return ResponseEntity.ok(product);
	}
	
	// --- NOVOS MÉTODOS DE CRUD (Simplificados para Teste) ---

	// --- Ler Todos os Produtos (Sem filtro de usuário) ---
	// Endpoint: GET /products
	@GetMapping // Mapeia para o RequestMapping base: /products
	public ResponseEntity<List<ProductEntity>> getAllProducts() {
		try {
			List<ProductEntity> products = repository.findAll(); // Busca TODOS os produtos

			if (products.isEmpty()) {
				return ResponseEntity.noContent().build(); // 204 No Content
			}
			return ResponseEntity.ok(products); // 200 OK com a lista de produtos
		} catch (Exception e) {
			System.err.println("Erro ao buscar todos os produtos: " + e.getMessage());
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(null); // 500 Internal Server Error
		}
	}

	// --- Criar Produto ---
	// Endpoint: POST /products
	@PostMapping
	public ResponseEntity<ProductEntity> createProduct(@RequestBody ProductEntity product) {
		try {
			// **Nenhum userId é setado aqui, o que significa que o campo userId no DB pode ser null
			// ou você precisará gerenciá-lo de outra forma caso seja NOT NULL no DB.**
			product.setId(null); // Garante que o ID será gerado automaticamente pelo banco

			ProductEntity savedProduct = repository.save(product); // Salva o novo produto
			return ResponseEntity.status(HttpStatus.CREATED).body(savedProduct); // 201 Created
		} catch (Exception e) {
			System.err.println("Erro ao criar produto: " + e.getMessage());
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(null);
		}
	}

	// --- Atualizar Produto ---
	// Endpoint: PUT /products/{id}
	// O PathVariable {id} refere-se ao ID do produto no DB
	@PutMapping("/{id}")
	public ResponseEntity<ProductEntity> updateProduct(@PathVariable Long id, @RequestBody ProductEntity product) {
		try {
			// Verifica se o produto existe (não verifica userId)
			if (!repository.existsById(id)) {
				return ResponseEntity.status(HttpStatus.NOT_FOUND).build(); // 404 Not Found
			}

			product.setId(id); // Garante que o ID do objeto seja o da URL
			// **Nenhum userId é setado aqui, mantendo a simplicidade.**

			ProductEntity updatedProduct = repository.save(product); // Atualiza o produto
			return ResponseEntity.ok(updatedProduct); // 200 OK
		} catch (Exception e) {
			System.err.println("Erro ao atualizar produto: " + e.getMessage());
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(null);
		}
	}

	// --- Deletar Produto ---
	// Endpoint: DELETE /products/{id}
	@DeleteMapping("/{id}")
	public ResponseEntity<Void> deleteProduct(@PathVariable Long id) {
		try {
			// Verifica se o produto existe antes de deletar (não verifica userId)
			if (!repository.existsById(id)) {
				return ResponseEntity.status(HttpStatus.NOT_FOUND).build(); // 404 Not Found
			}

			repository.deleteById(id); // Deleta o produto
			return ResponseEntity.noContent().build(); // 204 No Content (sucesso sem corpo)
		} catch (Exception e) {
			System.err.println("Erro ao deletar produto: " + e.getMessage());
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(null);
		}
	}
}
